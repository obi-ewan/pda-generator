{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _slicedToArray = require(\"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _wrapNativeSuper = require(\"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nvar bs58_1 = __importDefault(require(\"bs58\"));\n// TODO: Make sure this polyfill not included when not required\nvar encoding = __importStar(require(\"text-encoding-utf-8\"));\nvar ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\nvar textDecoder = new ResolvedTextDecoder(\"utf-8\", {\n  fatal: true\n});\nfunction baseEncode(value) {\n  if (typeof value === \"string\") {\n    value = Buffer.from(value, \"utf8\");\n  }\n  return bs58_1.default.encode(Buffer.from(value));\n}\nexports.baseEncode = baseEncode;\nfunction baseDecode(value) {\n  return Buffer.from(bs58_1.default.decode(value));\n}\nexports.baseDecode = baseDecode;\nvar INITIAL_LENGTH = 1024;\nvar BorshError = /*#__PURE__*/function (_Error) {\n  _inherits(BorshError, _Error);\n  var _super = _createSuper(BorshError);\n  function BorshError(message) {\n    var _this;\n    _classCallCheck(this, BorshError);\n    _this = _super.call(this, message);\n    _this.fieldPath = [];\n    _this.originalMessage = message;\n    return _this;\n  }\n  _createClass(BorshError, [{\n    key: \"addToFieldPath\",\n    value: function addToFieldPath(fieldName) {\n      this.fieldPath.splice(0, 0, fieldName);\n      // NOTE: Modifying message directly as jest doesn't use .toString()\n      this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n    }\n  }]);\n  return BorshError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nexports.BorshError = BorshError;\n/// Binary encoder.\nvar BinaryWriter = /*#__PURE__*/function () {\n  function BinaryWriter() {\n    _classCallCheck(this, BinaryWriter);\n    this.buf = Buffer.alloc(INITIAL_LENGTH);\n    this.length = 0;\n  }\n  _createClass(BinaryWriter, [{\n    key: \"maybeResize\",\n    value: function maybeResize() {\n      if (this.buf.length < 16 + this.length) {\n        this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\n      }\n    }\n  }, {\n    key: \"writeU8\",\n    value: function writeU8(value) {\n      this.maybeResize();\n      this.buf.writeUInt8(value, this.length);\n      this.length += 1;\n    }\n  }, {\n    key: \"writeU16\",\n    value: function writeU16(value) {\n      this.maybeResize();\n      this.buf.writeUInt16LE(value, this.length);\n      this.length += 2;\n    }\n  }, {\n    key: \"writeU32\",\n    value: function writeU32(value) {\n      this.maybeResize();\n      this.buf.writeUInt32LE(value, this.length);\n      this.length += 4;\n    }\n  }, {\n    key: \"writeU64\",\n    value: function writeU64(value) {\n      this.maybeResize();\n      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 8)));\n    }\n  }, {\n    key: \"writeU128\",\n    value: function writeU128(value) {\n      this.maybeResize();\n      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 16)));\n    }\n  }, {\n    key: \"writeU256\",\n    value: function writeU256(value) {\n      this.maybeResize();\n      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 32)));\n    }\n  }, {\n    key: \"writeU512\",\n    value: function writeU512(value) {\n      this.maybeResize();\n      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 64)));\n    }\n  }, {\n    key: \"writeBuffer\",\n    value: function writeBuffer(buffer) {\n      // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n      this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), buffer, Buffer.alloc(INITIAL_LENGTH)]);\n      this.length += buffer.length;\n    }\n  }, {\n    key: \"writeString\",\n    value: function writeString(str) {\n      this.maybeResize();\n      var b = Buffer.from(str, \"utf8\");\n      this.writeU32(b.length);\n      this.writeBuffer(b);\n    }\n  }, {\n    key: \"writeFixedArray\",\n    value: function writeFixedArray(array) {\n      this.writeBuffer(Buffer.from(array));\n    }\n  }, {\n    key: \"writeArray\",\n    value: function writeArray(array, fn) {\n      this.maybeResize();\n      this.writeU32(array.length);\n      var _iterator = _createForOfIteratorHelper(array),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var elem = _step.value;\n          this.maybeResize();\n          fn(elem);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return this.buf.subarray(0, this.length);\n    }\n  }]);\n  return BinaryWriter;\n}();\nexports.BinaryWriter = BinaryWriter;\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n  var originalMethod = propertyDescriptor.value;\n  propertyDescriptor.value = function () {\n    try {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return originalMethod.apply(this, args);\n    } catch (e) {\n      if (e instanceof RangeError) {\n        var code = e.code;\n        if ([\"ERR_BUFFER_OUT_OF_BOUNDS\", \"ERR_OUT_OF_RANGE\"].indexOf(code) >= 0) {\n          throw new BorshError(\"Reached the end of buffer when deserializing\");\n        }\n      }\n      throw e;\n    }\n  };\n}\nvar BinaryReader = /*#__PURE__*/function () {\n  function BinaryReader(buf) {\n    _classCallCheck(this, BinaryReader);\n    this.buf = buf;\n    this.offset = 0;\n  }\n  _createClass(BinaryReader, [{\n    key: \"readU8\",\n    value: function readU8() {\n      var value = this.buf.readUInt8(this.offset);\n      this.offset += 1;\n      return value;\n    }\n  }, {\n    key: \"readU16\",\n    value: function readU16() {\n      var value = this.buf.readUInt16LE(this.offset);\n      this.offset += 2;\n      return value;\n    }\n  }, {\n    key: \"readU32\",\n    value: function readU32() {\n      var value = this.buf.readUInt32LE(this.offset);\n      this.offset += 4;\n      return value;\n    }\n  }, {\n    key: \"readU64\",\n    value: function readU64() {\n      var buf = this.readBuffer(8);\n      return new bn_js_1.default(buf, \"le\");\n    }\n  }, {\n    key: \"readU128\",\n    value: function readU128() {\n      var buf = this.readBuffer(16);\n      return new bn_js_1.default(buf, \"le\");\n    }\n  }, {\n    key: \"readU256\",\n    value: function readU256() {\n      var buf = this.readBuffer(32);\n      return new bn_js_1.default(buf, \"le\");\n    }\n  }, {\n    key: \"readU512\",\n    value: function readU512() {\n      var buf = this.readBuffer(64);\n      return new bn_js_1.default(buf, \"le\");\n    }\n  }, {\n    key: \"readBuffer\",\n    value: function readBuffer(len) {\n      if (this.offset + len > this.buf.length) {\n        throw new BorshError(\"Expected buffer length \".concat(len, \" isn't within bounds\"));\n      }\n      var result = this.buf.slice(this.offset, this.offset + len);\n      this.offset += len;\n      return result;\n    }\n  }, {\n    key: \"readString\",\n    value: function readString() {\n      var len = this.readU32();\n      var buf = this.readBuffer(len);\n      try {\n        // NOTE: Using TextDecoder to fail on invalid UTF-8\n        return textDecoder.decode(buf);\n      } catch (e) {\n        throw new BorshError(\"Error decoding UTF-8 string: \".concat(e));\n      }\n    }\n  }, {\n    key: \"readFixedArray\",\n    value: function readFixedArray(len) {\n      return new Uint8Array(this.readBuffer(len));\n    }\n  }, {\n    key: \"readArray\",\n    value: function readArray(fn) {\n      var len = this.readU32();\n      var result = Array();\n      for (var i = 0; i < len; ++i) {\n        result.push(fn());\n      }\n      return result;\n    }\n  }]);\n  return BinaryReader;\n}();\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU8\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU16\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU32\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU64\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU128\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU256\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU512\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readString\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readFixedArray\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readArray\", null);\nexports.BinaryReader = BinaryReader;\nfunction capitalizeFirstLetter(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n  try {\n    // TODO: Handle missing values properly (make sure they never result in just skipped write)\n    if (typeof fieldType === \"string\") {\n      writer[\"write\".concat(capitalizeFirstLetter(fieldType))](value);\n    } else if (fieldType instanceof Array) {\n      if (typeof fieldType[0] === \"number\") {\n        if (value.length !== fieldType[0]) {\n          throw new BorshError(\"Expecting byte array of length \".concat(fieldType[0], \", but got \").concat(value.length, \" bytes\"));\n        }\n        writer.writeFixedArray(value);\n      } else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\n        if (value.length !== fieldType[1]) {\n          throw new BorshError(\"Expecting byte array of length \".concat(fieldType[1], \", but got \").concat(value.length, \" bytes\"));\n        }\n        for (var i = 0; i < fieldType[1]; i++) {\n          serializeField(schema, null, value[i], fieldType[0], writer);\n        }\n      } else {\n        writer.writeArray(value, function (item) {\n          serializeField(schema, fieldName, item, fieldType[0], writer);\n        });\n      }\n    } else if (fieldType.kind !== undefined) {\n      switch (fieldType.kind) {\n        case \"option\":\n          {\n            if (value === null || value === undefined) {\n              writer.writeU8(0);\n            } else {\n              writer.writeU8(1);\n              serializeField(schema, fieldName, value, fieldType.type, writer);\n            }\n            break;\n          }\n        case \"map\":\n          {\n            writer.writeU32(value.size);\n            value.forEach(function (val, key) {\n              serializeField(schema, fieldName, key, fieldType.key, writer);\n              serializeField(schema, fieldName, val, fieldType.value, writer);\n            });\n            break;\n          }\n        default:\n          throw new BorshError(\"FieldType \".concat(fieldType, \" unrecognized\"));\n      }\n    } else {\n      serializeStruct(schema, value, writer);\n    }\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n    throw error;\n  }\n}\nfunction serializeStruct(schema, obj, writer) {\n  if (typeof obj.borshSerialize === \"function\") {\n    obj.borshSerialize(writer);\n    return;\n  }\n  var structSchema = schema.get(obj.constructor);\n  if (!structSchema) {\n    throw new BorshError(\"Class \".concat(obj.constructor.name, \" is missing in schema\"));\n  }\n  if (structSchema.kind === \"struct\") {\n    structSchema.fields.map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        fieldName = _ref2[0],\n        fieldType = _ref2[1];\n      serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n    });\n  } else if (structSchema.kind === \"enum\") {\n    var name = obj[structSchema.field];\n    for (var idx = 0; idx < structSchema.values.length; ++idx) {\n      var _structSchema$values$ = _slicedToArray(structSchema.values[idx], 2),\n        fieldName = _structSchema$values$[0],\n        fieldType = _structSchema$values$[1];\n      if (fieldName === name) {\n        writer.writeU8(idx);\n        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        break;\n      }\n    }\n  } else {\n    throw new BorshError(\"Unexpected schema kind: \".concat(structSchema.kind, \" for \").concat(obj.constructor.name));\n  }\n}\n/// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\nfunction serialize(schema, obj) {\n  var Writer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BinaryWriter;\n  var writer = new Writer();\n  serializeStruct(schema, obj, writer);\n  return writer.toArray();\n}\nexports.serialize = serialize;\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n  try {\n    if (typeof fieldType === \"string\") {\n      return reader[\"read\".concat(capitalizeFirstLetter(fieldType))]();\n    }\n    if (fieldType instanceof Array) {\n      if (typeof fieldType[0] === \"number\") {\n        return reader.readFixedArray(fieldType[0]);\n      } else if (typeof fieldType[1] === \"number\") {\n        var arr = [];\n        for (var i = 0; i < fieldType[1]; i++) {\n          arr.push(deserializeField(schema, null, fieldType[0], reader));\n        }\n        return arr;\n      } else {\n        return reader.readArray(function () {\n          return deserializeField(schema, fieldName, fieldType[0], reader);\n        });\n      }\n    }\n    if (fieldType.kind === \"option\") {\n      var option = reader.readU8();\n      if (option) {\n        return deserializeField(schema, fieldName, fieldType.type, reader);\n      }\n      return undefined;\n    }\n    if (fieldType.kind === \"map\") {\n      var map = new Map();\n      var length = reader.readU32();\n      for (var _i = 0; _i < length; _i++) {\n        var key = deserializeField(schema, fieldName, fieldType.key, reader);\n        var val = deserializeField(schema, fieldName, fieldType.value, reader);\n        map.set(key, val);\n      }\n      return map;\n    }\n    return deserializeStruct(schema, fieldType, reader);\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n    throw error;\n  }\n}\nfunction deserializeStruct(schema, classType, reader) {\n  if (typeof classType.borshDeserialize === \"function\") {\n    return classType.borshDeserialize(reader);\n  }\n  var structSchema = schema.get(classType);\n  if (!structSchema) {\n    throw new BorshError(\"Class \".concat(classType.name, \" is missing in schema\"));\n  }\n  if (structSchema.kind === \"struct\") {\n    var result = {};\n    var _iterator2 = _createForOfIteratorHelper(schema.get(classType).fields),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n          fieldName = _step2$value[0],\n          fieldType = _step2$value[1];\n        result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return new classType(result);\n  }\n  if (structSchema.kind === \"enum\") {\n    var idx = reader.readU8();\n    if (idx >= structSchema.values.length) {\n      throw new BorshError(\"Enum index: \".concat(idx, \" is out of range\"));\n    }\n    var _structSchema$values$2 = _slicedToArray(structSchema.values[idx], 2),\n      _fieldName = _structSchema$values$2[0],\n      _fieldType = _structSchema$values$2[1];\n    var fieldValue = deserializeField(schema, _fieldName, _fieldType, reader);\n    return new classType(_defineProperty({}, _fieldName, fieldValue));\n  }\n  throw new BorshError(\"Unexpected schema kind: \".concat(structSchema.kind, \" for \").concat(classType.constructor.name));\n}\n/// Deserializes object from bytes using schema.\nfunction deserialize(schema, classType, buffer) {\n  var Reader = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BinaryReader;\n  var reader = new Reader(buffer);\n  var result = deserializeStruct(schema, classType, reader);\n  if (reader.offset < buffer.length) {\n    throw new BorshError(\"Unexpected \".concat(buffer.length - reader.offset, \" bytes after deserialized data\"));\n  }\n  return result;\n}\nexports.deserialize = deserialize;\n/// Deserializes object from bytes using schema, without checking the length read\nfunction deserializeUnchecked(schema, classType, buffer) {\n  var Reader = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BinaryReader;\n  var reader = new Reader(buffer);\n  return deserializeStruct(schema, classType, reader);\n}\nexports.deserializeUnchecked = deserializeUnchecked;","map":{"version":3,"names":["_defineProperty","require","default","_slicedToArray","_createForOfIteratorHelper","_classCallCheck","_createClass","_inherits","_createSuper","_wrapNativeSuper","__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","d","Reflect","decorate","i","__importStar","mod","__esModule","result","hasOwnProperty","call","__importDefault","exports","deserializeUnchecked","deserialize","serialize","BinaryReader","BinaryWriter","BorshError","baseDecode","baseEncode","bn_js_1","bs58_1","encoding","ResolvedTextDecoder","TextDecoder","textDecoder","fatal","Buffer","from","encode","decode","INITIAL_LENGTH","_Error","_super","message","_this","fieldPath","originalMessage","addToFieldPath","fieldName","splice","join","Error","buf","alloc","maybeResize","concat","writeU8","writeUInt8","writeU16","writeUInt16LE","writeU32","writeUInt32LE","writeU64","writeBuffer","toArray","writeU128","writeU256","writeU512","buffer","subarray","writeString","str","b","writeFixedArray","array","writeArray","fn","_iterator","_step","s","n","done","elem","err","e","f","handlingRangeError","propertyKey","propertyDescriptor","originalMethod","_len","args","Array","_key","apply","RangeError","code","indexOf","offset","readU8","readUInt8","readU16","readUInt16LE","readU32","readUInt32LE","readU64","readBuffer","readU128","readU256","readU512","len","slice","readString","readFixedArray","Uint8Array","readArray","push","prototype","capitalizeFirstLetter","string","charAt","toUpperCase","serializeField","schema","fieldType","writer","item","kind","type","size","forEach","val","serializeStruct","error","obj","borshSerialize","structSchema","constructor","name","fields","map","_ref","_ref2","field","idx","values","_structSchema$values$","Writer","deserializeField","reader","arr","option","Map","set","deserializeStruct","classType","borshDeserialize","_iterator2","_step2","_step2$value","_structSchema$values$2","fieldValue","Reader"],"sources":["/Users/ewanm/projects/node_modules/borsh/lib/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst bs58_1 = __importDefault(require(\"bs58\"));\n// TODO: Make sure this polyfill not included when not required\nconst encoding = __importStar(require(\"text-encoding-utf-8\"));\nconst ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\nconst textDecoder = new ResolvedTextDecoder(\"utf-8\", { fatal: true });\nfunction baseEncode(value) {\n    if (typeof value === \"string\") {\n        value = Buffer.from(value, \"utf8\");\n    }\n    return bs58_1.default.encode(Buffer.from(value));\n}\nexports.baseEncode = baseEncode;\nfunction baseDecode(value) {\n    return Buffer.from(bs58_1.default.decode(value));\n}\nexports.baseDecode = baseDecode;\nconst INITIAL_LENGTH = 1024;\nclass BorshError extends Error {\n    constructor(message) {\n        super(message);\n        this.fieldPath = [];\n        this.originalMessage = message;\n    }\n    addToFieldPath(fieldName) {\n        this.fieldPath.splice(0, 0, fieldName);\n        // NOTE: Modifying message directly as jest doesn't use .toString()\n        this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n    }\n}\nexports.BorshError = BorshError;\n/// Binary encoder.\nclass BinaryWriter {\n    constructor() {\n        this.buf = Buffer.alloc(INITIAL_LENGTH);\n        this.length = 0;\n    }\n    maybeResize() {\n        if (this.buf.length < 16 + this.length) {\n            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\n        }\n    }\n    writeU8(value) {\n        this.maybeResize();\n        this.buf.writeUInt8(value, this.length);\n        this.length += 1;\n    }\n    writeU16(value) {\n        this.maybeResize();\n        this.buf.writeUInt16LE(value, this.length);\n        this.length += 2;\n    }\n    writeU32(value) {\n        this.maybeResize();\n        this.buf.writeUInt32LE(value, this.length);\n        this.length += 4;\n    }\n    writeU64(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 8)));\n    }\n    writeU128(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 16)));\n    }\n    writeU256(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 32)));\n    }\n    writeU512(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 64)));\n    }\n    writeBuffer(buffer) {\n        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n        this.buf = Buffer.concat([\n            Buffer.from(this.buf.subarray(0, this.length)),\n            buffer,\n            Buffer.alloc(INITIAL_LENGTH),\n        ]);\n        this.length += buffer.length;\n    }\n    writeString(str) {\n        this.maybeResize();\n        const b = Buffer.from(str, \"utf8\");\n        this.writeU32(b.length);\n        this.writeBuffer(b);\n    }\n    writeFixedArray(array) {\n        this.writeBuffer(Buffer.from(array));\n    }\n    writeArray(array, fn) {\n        this.maybeResize();\n        this.writeU32(array.length);\n        for (const elem of array) {\n            this.maybeResize();\n            fn(elem);\n        }\n    }\n    toArray() {\n        return this.buf.subarray(0, this.length);\n    }\n}\nexports.BinaryWriter = BinaryWriter;\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n    const originalMethod = propertyDescriptor.value;\n    propertyDescriptor.value = function (...args) {\n        try {\n            return originalMethod.apply(this, args);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                const code = e.code;\n                if ([\"ERR_BUFFER_OUT_OF_BOUNDS\", \"ERR_OUT_OF_RANGE\"].indexOf(code) >= 0) {\n                    throw new BorshError(\"Reached the end of buffer when deserializing\");\n                }\n            }\n            throw e;\n        }\n    };\n}\nclass BinaryReader {\n    constructor(buf) {\n        this.buf = buf;\n        this.offset = 0;\n    }\n    readU8() {\n        const value = this.buf.readUInt8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    readU16() {\n        const value = this.buf.readUInt16LE(this.offset);\n        this.offset += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.buf.readUInt32LE(this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readU64() {\n        const buf = this.readBuffer(8);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU128() {\n        const buf = this.readBuffer(16);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU256() {\n        const buf = this.readBuffer(32);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU512() {\n        const buf = this.readBuffer(64);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readBuffer(len) {\n        if (this.offset + len > this.buf.length) {\n            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n        }\n        const result = this.buf.slice(this.offset, this.offset + len);\n        this.offset += len;\n        return result;\n    }\n    readString() {\n        const len = this.readU32();\n        const buf = this.readBuffer(len);\n        try {\n            // NOTE: Using TextDecoder to fail on invalid UTF-8\n            return textDecoder.decode(buf);\n        }\n        catch (e) {\n            throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n        }\n    }\n    readFixedArray(len) {\n        return new Uint8Array(this.readBuffer(len));\n    }\n    readArray(fn) {\n        const len = this.readU32();\n        const result = Array();\n        for (let i = 0; i < len; ++i) {\n            result.push(fn());\n        }\n        return result;\n    }\n}\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU8\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU16\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU32\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU64\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU128\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU256\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU512\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readString\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readFixedArray\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readArray\", null);\nexports.BinaryReader = BinaryReader;\nfunction capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n    try {\n        // TODO: Handle missing values properly (make sure they never result in just skipped write)\n        if (typeof fieldType === \"string\") {\n            writer[`write${capitalizeFirstLetter(fieldType)}`](value);\n        }\n        else if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                if (value.length !== fieldType[0]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n                }\n                writer.writeFixedArray(value);\n            }\n            else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\n                if (value.length !== fieldType[1]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);\n                }\n                for (let i = 0; i < fieldType[1]; i++) {\n                    serializeField(schema, null, value[i], fieldType[0], writer);\n                }\n            }\n            else {\n                writer.writeArray(value, (item) => {\n                    serializeField(schema, fieldName, item, fieldType[0], writer);\n                });\n            }\n        }\n        else if (fieldType.kind !== undefined) {\n            switch (fieldType.kind) {\n                case \"option\": {\n                    if (value === null || value === undefined) {\n                        writer.writeU8(0);\n                    }\n                    else {\n                        writer.writeU8(1);\n                        serializeField(schema, fieldName, value, fieldType.type, writer);\n                    }\n                    break;\n                }\n                case \"map\": {\n                    writer.writeU32(value.size);\n                    value.forEach((val, key) => {\n                        serializeField(schema, fieldName, key, fieldType.key, writer);\n                        serializeField(schema, fieldName, val, fieldType.value, writer);\n                    });\n                    break;\n                }\n                default:\n                    throw new BorshError(`FieldType ${fieldType} unrecognized`);\n            }\n        }\n        else {\n            serializeStruct(schema, value, writer);\n        }\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction serializeStruct(schema, obj, writer) {\n    if (typeof obj.borshSerialize === \"function\") {\n        obj.borshSerialize(writer);\n        return;\n    }\n    const structSchema = schema.get(obj.constructor);\n    if (!structSchema) {\n        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        structSchema.fields.map(([fieldName, fieldType]) => {\n            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        });\n    }\n    else if (structSchema.kind === \"enum\") {\n        const name = obj[structSchema.field];\n        for (let idx = 0; idx < structSchema.values.length; ++idx) {\n            const [fieldName, fieldType] = structSchema.values[idx];\n            if (fieldName === name) {\n                writer.writeU8(idx);\n                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n                break;\n            }\n        }\n    }\n    else {\n        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n    }\n}\n/// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\nfunction serialize(schema, obj, Writer = BinaryWriter) {\n    const writer = new Writer();\n    serializeStruct(schema, obj, writer);\n    return writer.toArray();\n}\nexports.serialize = serialize;\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n    try {\n        if (typeof fieldType === \"string\") {\n            return reader[`read${capitalizeFirstLetter(fieldType)}`]();\n        }\n        if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                return reader.readFixedArray(fieldType[0]);\n            }\n            else if (typeof fieldType[1] === \"number\") {\n                const arr = [];\n                for (let i = 0; i < fieldType[1]; i++) {\n                    arr.push(deserializeField(schema, null, fieldType[0], reader));\n                }\n                return arr;\n            }\n            else {\n                return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));\n            }\n        }\n        if (fieldType.kind === \"option\") {\n            const option = reader.readU8();\n            if (option) {\n                return deserializeField(schema, fieldName, fieldType.type, reader);\n            }\n            return undefined;\n        }\n        if (fieldType.kind === \"map\") {\n            let map = new Map();\n            const length = reader.readU32();\n            for (let i = 0; i < length; i++) {\n                const key = deserializeField(schema, fieldName, fieldType.key, reader);\n                const val = deserializeField(schema, fieldName, fieldType.value, reader);\n                map.set(key, val);\n            }\n            return map;\n        }\n        return deserializeStruct(schema, fieldType, reader);\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction deserializeStruct(schema, classType, reader) {\n    if (typeof classType.borshDeserialize === \"function\") {\n        return classType.borshDeserialize(reader);\n    }\n    const structSchema = schema.get(classType);\n    if (!structSchema) {\n        throw new BorshError(`Class ${classType.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        const result = {};\n        for (const [fieldName, fieldType] of schema.get(classType).fields) {\n            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n        }\n        return new classType(result);\n    }\n    if (structSchema.kind === \"enum\") {\n        const idx = reader.readU8();\n        if (idx >= structSchema.values.length) {\n            throw new BorshError(`Enum index: ${idx} is out of range`);\n        }\n        const [fieldName, fieldType] = structSchema.values[idx];\n        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n        return new classType({ [fieldName]: fieldValue });\n    }\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n}\n/// Deserializes object from bytes using schema.\nfunction deserialize(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    const result = deserializeStruct(schema, classType, reader);\n    if (reader.offset < buffer.length) {\n        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n    }\n    return result;\n}\nexports.deserialize = deserialize;\n/// Deserializes object from bytes using schema, without checking the length read\nfunction deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    return deserializeStruct(schema, classType, reader);\n}\nexports.deserializeUnchecked = deserializeUnchecked;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}