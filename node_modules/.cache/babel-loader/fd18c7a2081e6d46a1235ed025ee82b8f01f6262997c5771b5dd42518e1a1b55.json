{"ast":null,"code":"import _toArray from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _slicedToArray from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectWithoutProperties from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _createClass from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/Users/ewanm/projects/solana-pda-generator/solana-pda-generator/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nvar _excluded = [\"message\"];\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(toFailures);\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nvar StructError = /*#__PURE__*/function (_TypeError) {\n  _inherits(StructError, _TypeError);\n  var _super = _createSuper(StructError);\n  function StructError(failure, failures) {\n    var _this;\n    _classCallCheck(this, StructError);\n    var cached;\n    var message = failure.message,\n      rest = _objectWithoutProperties(failure, _excluded);\n    var path = failure.path;\n    var msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    _this = _super.call(this, msg);\n    Object.assign(_assertThisInitialized(_this), rest);\n    _this.name = _this.constructor.name;\n    _this.failures = function () {\n      var _cached;\n      return (_cached = cached) != null ? _cached : cached = [failure].concat(_toConsumableArray(failures()));\n    };\n    return _this;\n  }\n  return _createClass(StructError);\n}( /*#__PURE__*/_wrapNativeSuper(TypeError));\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\n\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n  var prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nfunction shiftIterator(input) {\n  var _input$next = input.next(),\n    done = _input$next.done,\n    value = _input$next.value;\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n  var path = context.path,\n    branch = context.branch;\n  var type = struct.type;\n  var _result = result,\n    refinement = _result.refinement,\n    _result$message = _result.message,\n    message = _result$message === void 0 ? \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\" : _result$message;\n  return _objectSpread(_objectSpread({\n    value: value,\n    type: type,\n    refinement: refinement,\n    key: path[path.length - 1],\n    path: path,\n    branch: branch\n  }, result), {}, {\n    message: message\n  });\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nfunction toFailures(result, context, struct, value) {\n  var _iterator, _step, r, failure;\n  return _regeneratorRuntime().wrap(function toFailures$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        if (!isIterable(result)) {\n          result = [result];\n        }\n        _iterator = _createForOfIteratorHelper(result);\n        _context.prev = 2;\n        _iterator.s();\n      case 4:\n        if ((_step = _iterator.n()).done) {\n          _context.next = 12;\n          break;\n        }\n        r = _step.value;\n        failure = toFailure(r, context, struct, value);\n        if (!failure) {\n          _context.next = 10;\n          break;\n        }\n        _context.next = 10;\n        return failure;\n      case 10:\n        _context.next = 4;\n        break;\n      case 12:\n        _context.next = 17;\n        break;\n      case 14:\n        _context.prev = 14;\n        _context.t0 = _context[\"catch\"](2);\n        _iterator.e(_context.t0);\n      case 17:\n        _context.prev = 17;\n        _iterator.f();\n        return _context.finish(17);\n      case 20:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _marked, null, [[2, 14, 17, 20]]);\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nfunction run(value, struct) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var _options$path, path, _options$branch, branch, _options$coerce, coerce, _options$mask, mask, ctx, key, valid, _iterator2, _step2, _failure, _iterator3, _step3, _step3$value, k, v, s, ts, _iterator5, _step5, t, _iterator4, _step4, failure;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _options$path = options.path, path = _options$path === void 0 ? [] : _options$path, _options$branch = options.branch, branch = _options$branch === void 0 ? [value] : _options$branch, _options$coerce = options.coerce, coerce = _options$coerce === void 0 ? false : _options$coerce, _options$mask = options.mask, mask = _options$mask === void 0 ? false : _options$mask;\n          ctx = {\n            path: path,\n            branch: branch\n          };\n          if (coerce) {\n            value = struct.coercer(value, ctx);\n            if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n              for (key in value) {\n                if (struct.schema[key] === undefined) {\n                  delete value[key];\n                }\n              }\n            }\n          }\n          valid = true;\n          _iterator2 = _createForOfIteratorHelper(struct.validator(value, ctx));\n          _context2.prev = 5;\n          _iterator2.s();\n        case 7:\n          if ((_step2 = _iterator2.n()).done) {\n            _context2.next = 14;\n            break;\n          }\n          _failure = _step2.value;\n          valid = false;\n          _context2.next = 12;\n          return [_failure, undefined];\n        case 12:\n          _context2.next = 7;\n          break;\n        case 14:\n          _context2.next = 19;\n          break;\n        case 16:\n          _context2.prev = 16;\n          _context2.t0 = _context2[\"catch\"](5);\n          _iterator2.e(_context2.t0);\n        case 19:\n          _context2.prev = 19;\n          _iterator2.f();\n          return _context2.finish(19);\n        case 22:\n          _iterator3 = _createForOfIteratorHelper(struct.entries(value, ctx));\n          _context2.prev = 23;\n          _iterator3.s();\n        case 25:\n          if ((_step3 = _iterator3.n()).done) {\n            _context2.next = 52;\n            break;\n          }\n          _step3$value = _slicedToArray(_step3.value, 3), k = _step3$value[0], v = _step3$value[1], s = _step3$value[2];\n          ts = run(v, s, {\n            path: k === undefined ? path : [].concat(_toConsumableArray(path), [k]),\n            branch: k === undefined ? branch : [].concat(_toConsumableArray(branch), [v]),\n            coerce: coerce,\n            mask: mask\n          });\n          _iterator5 = _createForOfIteratorHelper(ts);\n          _context2.prev = 29;\n          _iterator5.s();\n        case 31:\n          if ((_step5 = _iterator5.n()).done) {\n            _context2.next = 42;\n            break;\n          }\n          t = _step5.value;\n          if (!t[0]) {\n            _context2.next = 39;\n            break;\n          }\n          valid = false;\n          _context2.next = 37;\n          return [t[0], undefined];\n        case 37:\n          _context2.next = 40;\n          break;\n        case 39:\n          if (coerce) {\n            v = t[1];\n            if (k === undefined) {\n              value = v;\n            } else if (value instanceof Map) {\n              value.set(k, v);\n            } else if (value instanceof Set) {\n              value.add(v);\n            } else if (isObject(value)) {\n              value[k] = v;\n            }\n          }\n        case 40:\n          _context2.next = 31;\n          break;\n        case 42:\n          _context2.next = 47;\n          break;\n        case 44:\n          _context2.prev = 44;\n          _context2.t1 = _context2[\"catch\"](29);\n          _iterator5.e(_context2.t1);\n        case 47:\n          _context2.prev = 47;\n          _iterator5.f();\n          return _context2.finish(47);\n        case 50:\n          _context2.next = 25;\n          break;\n        case 52:\n          _context2.next = 57;\n          break;\n        case 54:\n          _context2.prev = 54;\n          _context2.t2 = _context2[\"catch\"](23);\n          _iterator3.e(_context2.t2);\n        case 57:\n          _context2.prev = 57;\n          _iterator3.f();\n          return _context2.finish(57);\n        case 60:\n          if (!valid) {\n            _context2.next = 79;\n            break;\n          }\n          _iterator4 = _createForOfIteratorHelper(struct.refiner(value, ctx));\n          _context2.prev = 62;\n          _iterator4.s();\n        case 64:\n          if ((_step4 = _iterator4.n()).done) {\n            _context2.next = 71;\n            break;\n          }\n          failure = _step4.value;\n          valid = false;\n          _context2.next = 69;\n          return [failure, undefined];\n        case 69:\n          _context2.next = 64;\n          break;\n        case 71:\n          _context2.next = 76;\n          break;\n        case 73:\n          _context2.prev = 73;\n          _context2.t3 = _context2[\"catch\"](62);\n          _iterator4.e(_context2.t3);\n        case 76:\n          _context2.prev = 76;\n          _iterator4.f();\n          return _context2.finish(76);\n        case 79:\n          if (!valid) {\n            _context2.next = 82;\n            break;\n          }\n          _context2.next = 82;\n          return [undefined, value];\n        case 82:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee, null, [[5, 16, 19, 22], [23, 54, 57, 60], [29, 44, 47, 50], [62, 73, 76, 79]]);\n  })();\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nvar Struct = /*#__PURE__*/function () {\n  function Struct(props) {\n    var _this2 = this;\n    _classCallCheck(this, Struct);\n    var type = props.type,\n      schema = props.schema,\n      validator = props.validator,\n      refiner = props.refiner,\n      _props$coercer = props.coercer,\n      coercer = _props$coercer === void 0 ? function (value) {\n        return value;\n      } : _props$coercer,\n      _props$entries = props.entries,\n      entries = _props$entries === void 0 ? /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee2);\n      }) : _props$entries;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n    if (validator) {\n      this.validator = function (value, context) {\n        var result = validator(value, context);\n        return toFailures(result, context, _this2, value);\n      };\n    } else {\n      this.validator = function () {\n        return [];\n      };\n    }\n    if (refiner) {\n      this.refiner = function (value, context) {\n        var result = refiner(value, context);\n        return toFailures(result, context, _this2, value);\n      };\n    } else {\n      this.refiner = function () {\n        return [];\n      };\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n  _createClass(Struct, [{\n    key: \"assert\",\n    value: function assert(value) {\n      return _assert(value, this);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n  }, {\n    key: \"create\",\n    value: function create(value) {\n      return _create(value, this);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n  }, {\n    key: \"is\",\n    value: function is(value) {\n      return _is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n  }, {\n    key: \"mask\",\n    value: function mask(value) {\n      return _mask(value, this);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _validate(value, this, options);\n    }\n  }]);\n  return Struct;\n}();\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction _assert(value, struct) {\n  var result = _validate(value, struct);\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nfunction _create(value, struct) {\n  var result = _validate(value, struct, {\n    coerce: true\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nfunction _mask(value, struct) {\n  var result = _validate(value, struct, {\n    coerce: true,\n    mask: true\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\n\nfunction _is(value, struct) {\n  var result = _validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nfunction _validate(value, struct) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var tuples = run(value, struct, options);\n  var tuple = shiftIterator(tuples);\n  if (tuple[0]) {\n    var error = new StructError(tuple[0], /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n      var _iterator6, _step6, t;\n      return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _iterator6 = _createForOfIteratorHelper(tuples);\n            _context4.prev = 1;\n            _iterator6.s();\n          case 3:\n            if ((_step6 = _iterator6.n()).done) {\n              _context4.next = 10;\n              break;\n            }\n            t = _step6.value;\n            if (!t[0]) {\n              _context4.next = 8;\n              break;\n            }\n            _context4.next = 8;\n            return t[0];\n          case 8:\n            _context4.next = 3;\n            break;\n          case 10:\n            _context4.next = 15;\n            break;\n          case 12:\n            _context4.prev = 12;\n            _context4.t0 = _context4[\"catch\"](1);\n            _iterator6.e(_context4.t0);\n          case 15:\n            _context4.prev = 15;\n            _iterator6.f();\n            return _context4.finish(15);\n          case 18:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee3, null, [[1, 12, 15, 18]]);\n    }));\n    return [error, undefined];\n  } else {\n    var v = tuple[1];\n    return [undefined, v];\n  }\n}\nfunction assign() {\n  for (var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++) {\n    Structs[_key] = arguments[_key];\n  }\n  var schemas = Structs.map(function (s) {\n    return s.schema;\n  });\n  var schema = Object.assign.apply(Object, [{}].concat(_toConsumableArray(schemas)));\n  return object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator: validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\nfunction deprecated(struct, log) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    refiner: function refiner(value, ctx) {\n      return value === undefined || struct.refiner(value, ctx);\n    },\n    validator: function validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n  }));\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value, ctx) {\n      var struct;\n      return _regeneratorRuntime().wrap(function entries$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            struct = fn(value, ctx);\n            return _context5.delegateYield(struct.entries(value, ctx), \"t0\", 2);\n          case 2:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, entries);\n    }),\n    validator: function validator(value, ctx) {\n      var struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n    coercer: function coercer(value, ctx) {\n      var struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nfunction lazy(fn) {\n  var struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value, ctx) {\n      var _struct;\n      return _regeneratorRuntime().wrap(function entries$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            (_struct = struct) != null ? _struct : struct = fn();\n            return _context6.delegateYield(struct.entries(value, ctx), \"t0\", 2);\n          case 2:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, entries);\n    }),\n    validator: function validator(value, ctx) {\n      var _struct2;\n      (_struct2 = struct) != null ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n    coercer: function coercer(value, ctx) {\n      var _struct3;\n      (_struct3 = struct) != null ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nfunction omit(struct, keys) {\n  var schema = struct.schema;\n  var subschema = _objectSpread({}, schema);\n  var _iterator7 = _createForOfIteratorHelper(keys),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var key = _step7.value;\n      delete subschema[key];\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return object(subschema);\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nfunction partial(struct) {\n  var schema = struct instanceof Struct ? _objectSpread({}, struct.schema) : _objectSpread({}, struct);\n  for (var key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nfunction pick(struct, keys) {\n  var schema = struct.schema;\n  var subschema = {};\n  var _iterator8 = _createForOfIteratorHelper(keys),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var key = _step8.value;\n      subschema[key] = schema[key];\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\n\nfunction any() {\n  return define('any', function () {\n    return true;\n  });\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var _iterator9, _step9, _step9$value, i, v;\n      return _regeneratorRuntime().wrap(function entries$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            if (!(Element && Array.isArray(value))) {\n              _context7.next = 18;\n              break;\n            }\n            _iterator9 = _createForOfIteratorHelper(value.entries());\n            _context7.prev = 2;\n            _iterator9.s();\n          case 4:\n            if ((_step9 = _iterator9.n()).done) {\n              _context7.next = 10;\n              break;\n            }\n            _step9$value = _slicedToArray(_step9.value, 2), i = _step9$value[0], v = _step9$value[1];\n            _context7.next = 8;\n            return [i, v, Element];\n          case 8:\n            _context7.next = 4;\n            break;\n          case 10:\n            _context7.next = 15;\n            break;\n          case 12:\n            _context7.prev = 12;\n            _context7.t0 = _context7[\"catch\"](2);\n            _iterator9.e(_context7.t0);\n          case 15:\n            _context7.prev = 15;\n            _iterator9.f();\n            return _context7.finish(15);\n          case 18:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, entries, null, [[2, 12, 15, 18]]);\n    }),\n    coercer: function coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator: function validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\nfunction boolean() {\n  return define('boolean', function (value) {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nfunction date() {\n  return define('date', function (value) {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n  });\n}\nfunction enums(values) {\n  var schema = {};\n  var description = values.map(function (v) {\n    return print(v);\n  }).join();\n  var _iterator10 = _createForOfIteratorHelper(values),\n    _step10;\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var key = _step10.value;\n      schema[key] = key;\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n  return new Struct({\n    type: 'enums',\n    schema: schema,\n    validator: function validator(value) {\n      return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a function.\n */\n\nfunction func() {\n  return define('func', function (value) {\n    return typeof value === 'function' || \"Expected a function, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nfunction instance(Class) {\n  return define('instance', function (value) {\n    return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\n\nfunction integer() {\n  return define('integer', function (value) {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n  });\n}\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value, ctx) {\n      var _iterator11, _step11, S;\n      return _regeneratorRuntime().wrap(function entries$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            _iterator11 = _createForOfIteratorHelper(Structs);\n            _context8.prev = 1;\n            _iterator11.s();\n          case 3:\n            if ((_step11 = _iterator11.n()).done) {\n              _context8.next = 8;\n              break;\n            }\n            S = _step11.value;\n            return _context8.delegateYield(S.entries(value, ctx), \"t0\", 6);\n          case 6:\n            _context8.next = 3;\n            break;\n          case 8:\n            _context8.next = 13;\n            break;\n          case 10:\n            _context8.prev = 10;\n            _context8.t1 = _context8[\"catch\"](1);\n            _iterator11.e(_context8.t1);\n          case 13:\n            _context8.prev = 13;\n            _iterator11.f();\n            return _context8.finish(13);\n          case 16:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, entries, null, [[1, 10, 13, 16]]);\n    }),\n    validator: /*#__PURE__*/_regeneratorRuntime().mark(function validator(value, ctx) {\n      var _iterator12, _step12, S;\n      return _regeneratorRuntime().wrap(function validator$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            _iterator12 = _createForOfIteratorHelper(Structs);\n            _context9.prev = 1;\n            _iterator12.s();\n          case 3:\n            if ((_step12 = _iterator12.n()).done) {\n              _context9.next = 8;\n              break;\n            }\n            S = _step12.value;\n            return _context9.delegateYield(S.validator(value, ctx), \"t0\", 6);\n          case 6:\n            _context9.next = 3;\n            break;\n          case 8:\n            _context9.next = 13;\n            break;\n          case 10:\n            _context9.prev = 10;\n            _context9.t1 = _context9[\"catch\"](1);\n            _iterator12.e(_context9.t1);\n          case 13:\n            _context9.prev = 13;\n            _iterator12.f();\n            return _context9.finish(13);\n          case 16:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, validator, null, [[1, 10, 13, 16]]);\n    }),\n    refiner: /*#__PURE__*/_regeneratorRuntime().mark(function refiner(value, ctx) {\n      var _iterator13, _step13, S;\n      return _regeneratorRuntime().wrap(function refiner$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            _iterator13 = _createForOfIteratorHelper(Structs);\n            _context10.prev = 1;\n            _iterator13.s();\n          case 3:\n            if ((_step13 = _iterator13.n()).done) {\n              _context10.next = 8;\n              break;\n            }\n            S = _step13.value;\n            return _context10.delegateYield(S.refiner(value, ctx), \"t0\", 6);\n          case 6:\n            _context10.next = 3;\n            break;\n          case 8:\n            _context10.next = 13;\n            break;\n          case 10:\n            _context10.prev = 10;\n            _context10.t1 = _context10[\"catch\"](1);\n            _iterator13.e(_context10.t1);\n          case 13:\n            _context10.prev = 13;\n            _iterator13.f();\n            return _context10.finish(13);\n          case 16:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, refiner, null, [[1, 10, 13, 16]]);\n    })\n  });\n}\nfunction literal(constant) {\n  var description = print(constant);\n  var t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator: function validator(value) {\n      return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n    }\n  });\n}\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var _iterator14, _step14, _step14$value, k, v;\n      return _regeneratorRuntime().wrap(function entries$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            if (!(Key && Value && value instanceof Map)) {\n              _context11.next = 20;\n              break;\n            }\n            _iterator14 = _createForOfIteratorHelper(value.entries());\n            _context11.prev = 2;\n            _iterator14.s();\n          case 4:\n            if ((_step14 = _iterator14.n()).done) {\n              _context11.next = 12;\n              break;\n            }\n            _step14$value = _slicedToArray(_step14.value, 2), k = _step14$value[0], v = _step14$value[1];\n            _context11.next = 8;\n            return [k, k, Key];\n          case 8:\n            _context11.next = 10;\n            return [k, v, Value];\n          case 10:\n            _context11.next = 4;\n            break;\n          case 12:\n            _context11.next = 17;\n            break;\n          case 14:\n            _context11.prev = 14;\n            _context11.t0 = _context11[\"catch\"](2);\n            _iterator14.e(_context11.t0);\n          case 17:\n            _context11.prev = 17;\n            _iterator14.f();\n            return _context11.finish(17);\n          case 20:\n          case \"end\":\n            return _context11.stop();\n        }\n      }, entries, null, [[2, 14, 17, 20]]);\n    }),\n    coercer: function coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n    validator: function validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\n\nfunction never() {\n  return define('never', function () {\n    return false;\n  });\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nfunction nullable(struct) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    validator: function validator(value, ctx) {\n      return value === null || struct.validator(value, ctx);\n    },\n    refiner: function refiner(value, ctx) {\n      return value === null || struct.refiner(value, ctx);\n    }\n  }));\n}\n/**\n * Ensure that a value is a number.\n */\n\nfunction number() {\n  return define('number', function (value) {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\nfunction object(schema) {\n  var knowns = schema ? Object.keys(schema) : [];\n  var Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var unknowns, _iterator15, _step15, key, _iterator16, _step16, _key2;\n      return _regeneratorRuntime().wrap(function entries$(_context12) {\n        while (1) switch (_context12.prev = _context12.next) {\n          case 0:\n            if (!(schema && isObject(value))) {\n              _context12.next = 37;\n              break;\n            }\n            unknowns = new Set(Object.keys(value));\n            _iterator15 = _createForOfIteratorHelper(knowns);\n            _context12.prev = 3;\n            _iterator15.s();\n          case 5:\n            if ((_step15 = _iterator15.n()).done) {\n              _context12.next = 12;\n              break;\n            }\n            key = _step15.value;\n            unknowns.delete(key);\n            _context12.next = 10;\n            return [key, value[key], schema[key]];\n          case 10:\n            _context12.next = 5;\n            break;\n          case 12:\n            _context12.next = 17;\n            break;\n          case 14:\n            _context12.prev = 14;\n            _context12.t0 = _context12[\"catch\"](3);\n            _iterator15.e(_context12.t0);\n          case 17:\n            _context12.prev = 17;\n            _iterator15.f();\n            return _context12.finish(17);\n          case 20:\n            _iterator16 = _createForOfIteratorHelper(unknowns);\n            _context12.prev = 21;\n            _iterator16.s();\n          case 23:\n            if ((_step16 = _iterator16.n()).done) {\n              _context12.next = 29;\n              break;\n            }\n            _key2 = _step16.value;\n            _context12.next = 27;\n            return [_key2, value[_key2], Never];\n          case 27:\n            _context12.next = 23;\n            break;\n          case 29:\n            _context12.next = 34;\n            break;\n          case 31:\n            _context12.prev = 31;\n            _context12.t1 = _context12[\"catch\"](21);\n            _iterator16.e(_context12.t1);\n          case 34:\n            _context12.prev = 34;\n            _iterator16.f();\n            return _context12.finish(34);\n          case 37:\n          case \"end\":\n            return _context12.stop();\n        }\n      }, entries, null, [[3, 14, 17, 20], [21, 31, 34, 37]]);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    },\n    coercer: function coercer(value) {\n      return isObject(value) ? _objectSpread({}, value) : value;\n    }\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nfunction optional(struct) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    validator: function validator(value, ctx) {\n      return value === undefined || struct.validator(value, ctx);\n    },\n    refiner: function refiner(value, ctx) {\n      return value === undefined || struct.refiner(value, ctx);\n    }\n  }));\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var k, v;\n      return _regeneratorRuntime().wrap(function entries$(_context13) {\n        while (1) switch (_context13.prev = _context13.next) {\n          case 0:\n            if (!isObject(value)) {\n              _context13.next = 11;\n              break;\n            }\n            _context13.t0 = _regeneratorRuntime().keys(value);\n          case 2:\n            if ((_context13.t1 = _context13.t0()).done) {\n              _context13.next = 11;\n              break;\n            }\n            k = _context13.t1.value;\n            v = value[k];\n            _context13.next = 7;\n            return [k, k, Key];\n          case 7:\n            _context13.next = 9;\n            return [k, v, Value];\n          case 9:\n            _context13.next = 2;\n            break;\n          case 11:\n          case \"end\":\n            return _context13.stop();\n        }\n      }, entries);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nfunction regexp() {\n  return define('regexp', function (value) {\n    return value instanceof RegExp;\n  });\n}\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var _iterator17, _step17, v;\n      return _regeneratorRuntime().wrap(function entries$(_context14) {\n        while (1) switch (_context14.prev = _context14.next) {\n          case 0:\n            if (!(Element && value instanceof Set)) {\n              _context14.next = 18;\n              break;\n            }\n            _iterator17 = _createForOfIteratorHelper(value);\n            _context14.prev = 2;\n            _iterator17.s();\n          case 4:\n            if ((_step17 = _iterator17.n()).done) {\n              _context14.next = 10;\n              break;\n            }\n            v = _step17.value;\n            _context14.next = 8;\n            return [v, v, Element];\n          case 8:\n            _context14.next = 4;\n            break;\n          case 10:\n            _context14.next = 15;\n            break;\n          case 12:\n            _context14.prev = 12;\n            _context14.t0 = _context14[\"catch\"](2);\n            _iterator17.e(_context14.t0);\n          case 15:\n            _context14.prev = 15;\n            _iterator17.f();\n            return _context14.finish(15);\n          case 18:\n          case \"end\":\n            return _context14.stop();\n        }\n      }, entries, null, [[2, 12, 15, 18]]);\n    }),\n    coercer: function coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n    validator: function validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\nfunction string() {\n  return define('string', function (value) {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\nfunction tuple(Elements) {\n  var Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var length, i;\n      return _regeneratorRuntime().wrap(function entries$(_context15) {\n        while (1) switch (_context15.prev = _context15.next) {\n          case 0:\n            if (!Array.isArray(value)) {\n              _context15.next = 9;\n              break;\n            }\n            length = Math.max(Elements.length, value.length);\n            i = 0;\n          case 3:\n            if (!(i < length)) {\n              _context15.next = 9;\n              break;\n            }\n            _context15.next = 6;\n            return [i, value[i], Elements[i] || Never];\n          case 6:\n            i++;\n            _context15.next = 3;\n            break;\n          case 9:\n          case \"end\":\n            return _context15.stop();\n        }\n      }, entries);\n    }),\n    validator: function validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nfunction type(schema) {\n  var keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema: schema,\n    entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {\n      var _i, _keys, k;\n      return _regeneratorRuntime().wrap(function entries$(_context16) {\n        while (1) switch (_context16.prev = _context16.next) {\n          case 0:\n            if (!isObject(value)) {\n              _context16.next = 9;\n              break;\n            }\n            _i = 0, _keys = keys;\n          case 2:\n            if (!(_i < _keys.length)) {\n              _context16.next = 9;\n              break;\n            }\n            k = _keys[_i];\n            _context16.next = 6;\n            return [k, value[k], schema[k]];\n          case 6:\n            _i++;\n            _context16.next = 2;\n            break;\n          case 9:\n          case \"end\":\n            return _context16.stop();\n        }\n      }, entries);\n    }),\n    validator: function validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n  });\n}\nfunction union(Structs) {\n  var description = Structs.map(function (s) {\n    return s.type;\n  }).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n    validator: function validator(value, ctx) {\n      var failures = [];\n      var _iterator18 = _createForOfIteratorHelper(Structs),\n        _step18;\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var S = _step18.value;\n          var _run = run(value, S, ctx),\n            _run2 = _toArray(_run),\n            tuples = _run2.slice(0);\n          var _tuples = _slicedToArray(tuples, 1),\n            first = _tuples[0];\n          if (!first[0]) {\n            return [];\n          } else {\n            var _iterator19 = _createForOfIteratorHelper(tuples),\n              _step19;\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var _step19$value = _slicedToArray(_step19.value, 1),\n                  failure = _step19$value[0];\n                if (failure) {\n                  failures.push(failure);\n                }\n              }\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value)].concat(failures);\n    }\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nfunction unknown() {\n  return define('unknown', function () {\n    return true;\n  });\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction coerce(struct, condition, _coercer) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    coercer: function coercer(value, ctx) {\n      return _is(value, condition) ? struct.coercer(_coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  }));\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction defaulted(struct, fallback) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return coerce(struct, unknown(), function (x) {\n    var f = typeof fallback === 'function' ? fallback() : fallback;\n    if (x === undefined) {\n      return f;\n    }\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      var ret = _objectSpread({}, x);\n      var changed = false;\n      for (var key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n      if (changed) {\n        return ret;\n      }\n    }\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction trimmed(struct) {\n  return coerce(struct, string(), function (x) {\n    return x.trim();\n  });\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nfunction empty(struct) {\n  var expected = \"Expected an empty \" + struct.type;\n  return refine(struct, 'empty', function (value) {\n    if (value instanceof Map || value instanceof Set) {\n      var _size = value.size;\n      return _size === 0 || expected + \" but received one with a size of `\" + _size + \"`\";\n    } else {\n      var length = value.length;\n      return length === 0 || expected + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nfunction max(struct, threshold) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var exclusive = options.exclusive;\n  return refine(struct, 'max', function (value) {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nfunction min(struct, threshold) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var exclusive = options.exclusive;\n  return refine(struct, 'min', function (value) {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', function (value) {\n    return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + \"/` but received \\\"\" + value + \"\\\"\";\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nfunction size(struct, min) {\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min;\n  var expected = \"Expected a \" + struct.type;\n  var of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n  return refine(struct, 'size', function (value) {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n    } else if (value instanceof Map || value instanceof Set) {\n      var _size2 = value.size;\n      return min <= _size2 && _size2 <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + _size2 + \"`\";\n    } else {\n      var length = value.length;\n      return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nfunction refine(struct, name, refiner) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    refiner: function (_refiner) {\n      var _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(refiner);\n      function refiner(_x, _x2) {\n        var _args17 = arguments;\n        return _regeneratorRuntime().wrap(function refiner$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              return _context17.delegateYield(_refiner.apply(this, _args17), \"t0\", 1);\n            case 1:\n              return _context17.abrupt(\"return\", _context17.t0);\n            case 2:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _marked2, this);\n      }\n      refiner.toString = function () {\n        return _refiner.toString();\n      };\n      return refiner;\n    }( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(value, ctx) {\n      var result, failures, _iterator20, _step20, failure;\n      return _regeneratorRuntime().wrap(function _callee4$(_context18) {\n        while (1) switch (_context18.prev = _context18.next) {\n          case 0:\n            return _context18.delegateYield(struct.refiner(value, ctx), \"t0\", 1);\n          case 1:\n            result = refiner(value, ctx);\n            failures = toFailures(result, ctx, struct, value);\n            _iterator20 = _createForOfIteratorHelper(failures);\n            _context18.prev = 4;\n            _iterator20.s();\n          case 6:\n            if ((_step20 = _iterator20.n()).done) {\n              _context18.next = 12;\n              break;\n            }\n            failure = _step20.value;\n            _context18.next = 10;\n            return _objectSpread(_objectSpread({}, failure), {}, {\n              refinement: name\n            });\n          case 10:\n            _context18.next = 6;\n            break;\n          case 12:\n            _context18.next = 17;\n            break;\n          case 14:\n            _context18.prev = 14;\n            _context18.t1 = _context18[\"catch\"](4);\n            _iterator20.e(_context18.t1);\n          case 17:\n            _context18.prev = 17;\n            _iterator20.f();\n            return _context18.finish(17);\n          case 20:\n          case \"end\":\n            return _context18.stop();\n        }\n      }, _callee4, null, [[4, 14, 17, 20]]);\n    }))\n  }));\n}\nexport { Struct, StructError, any, array, _assert as assert, assign, boolean, coerce, _create as create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, _is as is, lazy, literal, map, _mask as mask, max, min, never, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, _validate as validate };","map":{"version":3,"names":["toFailures","StructError","_TypeError","_inherits","_super","_createSuper","failure","failures","_this","_classCallCheck","cached","message","rest","_objectWithoutProperties","_excluded","path","msg","length","join","call","Object","assign","_assertThisInitialized","name","constructor","_cached","concat","_toConsumableArray","_createClass","_wrapNativeSuper","TypeError","isIterable","x","isObject","Symbol","iterator","isPlainObject","prototype","toString","getPrototypeOf","print","value","JSON","stringify","shiftIterator","input","_input$next","next","done","undefined","toFailure","result","context","struct","branch","type","_result","refinement","_result$message","_objectSpread","key","_iterator","_step","r","_regeneratorRuntime","wrap","toFailures$","_context","prev","_createForOfIteratorHelper","s","n","t0","e","f","finish","stop","_marked","run","options","arguments","mark","_callee","_options$path","_options$branch","_options$coerce","coerce","_options$mask","mask","ctx","valid","_iterator2","_step2","_failure","_iterator3","_step3","_step3$value","k","v","ts","_iterator5","_step5","t","_iterator4","_step4","_callee$","_context2","coercer","schema","Array","isArray","validator","entries","_slicedToArray","Map","set","Set","add","t1","t2","refiner","t3","Struct","props","_this2","_props$coercer","_props$entries","_callee2","_callee2$","_context3","assert","create","is","validate","tuples","tuple","error","_callee3","_iterator6","_step6","_callee3$","_context4","_len","Structs","_key","schemas","map","apply","object","define","deprecated","log","dynamic","fn","entries$","_context5","delegateYield","lazy","_struct","_context6","_struct2","_struct3","omit","keys","subschema","_iterator7","_step7","err","partial","optional","pick","_iterator8","_step8","console","warn","any","array","Element","_iterator9","_step9","_step9$value","i","_context7","slice","boolean","date","Date","isNaN","getTime","enums","values","description","_iterator10","_step10","includes","func","instance","Class","integer","Number","isInteger","intersection","_iterator11","_step11","S","_context8","_iterator12","_step12","validator$","_context9","_iterator13","_step13","refiner$","_context10","literal","constant","Key","Value","_iterator14","_step14","_step14$value","_context11","never","nullable","number","knowns","Never","unknowns","_iterator15","_step15","_iterator16","_step16","_key2","_context12","delete","record","_context13","regexp","RegExp","_iterator17","_step17","_context14","string","Elements","_context15","Math","max","_i","_keys","_context16","union","_iterator18","_step18","_run","_run2","_toArray","_tuples","first","_iterator19","_step19","_step19$value","push","unknown","condition","defaulted","fallback","strict","ret","changed","trimmed","trim","empty","expected","refine","size","threshold","exclusive","min","pattern","test","source","of","_refiner","_marked2","_x","_x2","_args17","_context17","abrupt","_callee4","_iterator20","_step20","_callee4$","_context18"],"sources":["/Users/ewanm/projects/node_modules/superstruct/src/error.ts","/Users/ewanm/projects/node_modules/superstruct/src/utils.ts","/Users/ewanm/projects/node_modules/superstruct/src/struct.ts","/Users/ewanm/projects/node_modules/superstruct/src/structs/utilities.ts","/Users/ewanm/projects/node_modules/superstruct/src/structs/types.ts","/Users/ewanm/projects/node_modules/superstruct/src/structs/coercions.ts","/Users/ewanm/projects/node_modules/superstruct/src/structs/refinements.ts"],"sourcesContent":["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\nexport type Failure = {\n  value: any\n  key: any\n  type: string\n  refinement: string | undefined\n  message: string\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\n\nexport class StructError extends TypeError {\n  value: any\n  key!: any\n  type!: string\n  refinement!: string | undefined\n  path!: Array<any>\n  branch!: Array<any>\n  failures: () => Array<Failure>;\n  [x: string]: any\n\n  constructor(failure: Failure, failures: () => Generator<Failure>) {\n    let cached: Array<Failure> | undefined\n    const { message, ...rest } = failure\n    const { path } = failure\n    const msg =\n      path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`\n    super(msg)\n    Object.assign(this, rest)\n    this.name = this.constructor.name\n    this.failures = () => {\n      return (cached ??= [failure, ...failures()])\n    }\n  }\n}\n","import { Struct, Infer, Result, Context, Describe } from './struct'\nimport { Failure } from './error'\n\n/**\n * Check if a value is an iterator.\n */\n\nfunction isIterable<T>(x: unknown): x is Iterable<T> {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function'\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isObject(x: unknown): x is object {\n  return typeof x === 'object' && x != null\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isPlainObject(x: unknown): x is { [key: string]: any } {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(x)\n  return prototype === null || prototype === Object.prototype\n}\n\n/**\n * Return a value as a printable string.\n */\n\nexport function print(value: any): string {\n  return typeof value === 'string' ? JSON.stringify(value) : `${value}`\n}\n\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nexport function shiftIterator<T>(input: Iterator<T>): T | undefined {\n  const { done, value } = input.next()\n  return done ? undefined : value\n}\n\n/**\n * Convert a single validation result to a failure.\n */\n\nexport function toFailure<T, S>(\n  result: string | boolean | Partial<Failure>,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): Failure | undefined {\n  if (result === true) {\n    return\n  } else if (result === false) {\n    result = {}\n  } else if (typeof result === 'string') {\n    result = { message: result }\n  }\n\n  const { path, branch } = context\n  const { type } = struct\n  const {\n    refinement,\n    message = `Expected a value of type \\`${type}\\`${\n      refinement ? ` with refinement \\`${refinement}\\`` : ''\n    }, but received: \\`${print(value)}\\``,\n  } = result\n\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message,\n  }\n}\n\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nexport function* toFailures<T, S>(\n  result: Result,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): IterableIterator<Failure> {\n  if (!isIterable(result)) {\n    result = [result]\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value)\n\n    if (failure) {\n      yield failure\n    }\n  }\n}\n\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nexport function* run<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    path?: any[]\n    branch?: any[]\n    coerce?: boolean\n    mask?: boolean\n  } = {}\n): IterableIterator<[Failure, undefined] | [undefined, T]> {\n  const { path = [], branch = [value], coerce = false, mask = false } = options\n  const ctx: Context = { path, branch }\n\n  if (coerce) {\n    value = struct.coercer(value, ctx)\n\n    if (\n      mask &&\n      struct.type !== 'type' &&\n      isObject(struct.schema) &&\n      isObject(value) &&\n      !Array.isArray(value)\n    ) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key]\n        }\n      }\n    }\n  }\n\n  let valid = true\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false\n    yield [failure, undefined]\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s as Struct, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask,\n    })\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false\n        yield [t[0], undefined]\n      } else if (coerce) {\n        v = t[1]\n\n        if (k === undefined) {\n          value = v\n        } else if (value instanceof Map) {\n          value.set(k, v)\n        } else if (value instanceof Set) {\n          value.add(v)\n        } else if (isObject(value)) {\n          value[k] = v\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value as T, ctx)) {\n      valid = false\n      yield [failure, undefined]\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value as T]\n  }\n}\n\n/**\n * Assign properties from one type to another, overwriting existing.\n */\n\nexport type Assign<T, U> = Simplify<U & Omit<T, keyof U>>\n\n/**\n * A schema for enum structs.\n */\n\nexport type EnumSchema<T extends string | number> = { [K in T]: K }\n\n/**\n * Check if a type is an exact match.\n */\n\nexport type IsMatch<T, G> = T extends G ? (G extends T ? T : never) : never\n\n/**\n * Check if a type is a record type.\n */\n\nexport type IsRecord<T> = T extends object\n  ? string extends keyof T\n    ? T\n    : never\n  : never\n/**\n * Check if a type is a tuple.\n */\n\nexport type IsTuple<T> = T extends [any]\n  ? T\n  : T extends [any, any]\n  ? T\n  : T extends [any, any, any]\n  ? T\n  : T extends [any, any, any, any]\n  ? T\n  : T extends [any, any, any, any, any]\n  ? T\n  : never\n\n/**\n * Check if a type is a union.\n */\n\nexport type IsUnion<T, U extends T = T> = (\n  T extends any ? (U extends T ? false : true) : false\n) extends false\n  ? never\n  : T\n\n/**\n * A schema for object structs.\n */\n\nexport type ObjectSchema = Record<string, Struct<any, any>>\n\n/**\n * Infer a type from an object struct schema.\n */\n\nexport type ObjectType<S extends ObjectSchema> = Simplify<\n  Optionalize<{ [K in keyof S]: Infer<S[K]> }>\n>\n\n/**\n * Omit properties from a type that extend from a specific type.\n */\n\nexport type OmitBy<T, V> = Omit<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Normalize properties of a type that allow `undefined` to make them optional.\n */\n\nexport type Optionalize<S extends object> = OmitBy<S, undefined> &\n  Partial<PickBy<S, undefined>>\n\n/**\n * Transform an object schema type to represent a partial.\n */\n\nexport type PartialObjectSchema<S extends ObjectSchema> = {\n  [K in keyof S]: Struct<Infer<S[K]> | undefined>\n}\n\n/**\n * Pick properties from a type that extend from a specific type.\n */\n\nexport type PickBy<T, V> = Pick<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Simplifies a type definition to its most basic representation.\n */\n\nexport type Simplify<T> = T extends any[] | Date\n  ? T\n  : { [K in keyof T]: T[K] } & {}\n\nexport type If<B extends Boolean, Then, Else> = B extends true ? Then : Else\n\n/**\n * A schema for any type of struct.\n */\n\nexport type StructSchema<T> = [T] extends [string]\n  ? [T] extends [IsMatch<T, string>]\n    ? null\n    : [T] extends [IsUnion<T>]\n    ? EnumSchema<T>\n    : T\n  : [T] extends [number]\n  ? [T] extends [IsMatch<T, number>]\n    ? null\n    : [T] extends [IsUnion<T>]\n    ? EnumSchema<T>\n    : T\n  : [T] extends [boolean]\n  ? [T] extends [IsMatch<T, boolean>]\n    ? null\n    : T\n  : T extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : T extends Array<infer E>\n  ? T extends IsTuple<T>\n    ? null\n    : Struct<E>\n  : T extends object\n  ? T extends IsRecord<T>\n    ? null\n    : { [K in keyof T]: Describe<T[K]> }\n  : null\n\n/**\n * A schema for tuple structs.\n */\n\nexport type TupleSchema<T> = { [K in keyof T]: Struct<T[K]> }\n","import { toFailures, shiftIterator, StructSchema, run } from './utils'\nimport { StructError, Failure } from './error'\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nexport class Struct<T = unknown, S = unknown> {\n  readonly TYPE!: T\n  type: string\n  schema: S\n  coercer: (value: unknown, context: Context) => unknown\n  validator: (value: unknown, context: Context) => Iterable<Failure>\n  refiner: (value: T, context: Context) => Iterable<Failure>\n  entries: (\n    value: unknown,\n    context: Context\n  ) => Iterable<[string | number, unknown, Struct<any> | Struct<never>]>\n\n  constructor(props: {\n    type: string\n    schema: S\n    coercer?: Coercer\n    validator?: Validator\n    refiner?: Refiner<T>\n    entries?: Struct<T, S>['entries']\n  }) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = (value: unknown) => value,\n      entries = function* () {},\n    } = props\n\n    this.type = type\n    this.schema = schema\n    this.entries = entries\n    this.coercer = coercer\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.validator = () => []\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.refiner = () => []\n    }\n  }\n\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n  assert(value: unknown): asserts value is T {\n    return assert(value, this)\n  }\n\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n  create(value: unknown): T {\n    return create(value, this)\n  }\n\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n  is(value: unknown): value is T {\n    return is(value, this)\n  }\n\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n  mask(value: unknown): T {\n    return mask(value, this)\n  }\n\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n  validate(\n    value: unknown,\n    options: {\n      coerce?: boolean\n    } = {}\n  ): [StructError, undefined] | [undefined, T] {\n    return validate(value, this, options)\n  }\n}\n\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\nexport function assert<T, S>(\n  value: unknown,\n  struct: Struct<T, S>\n): asserts value is T {\n  const result = validate(value, struct)\n\n  if (result[0]) {\n    throw result[0]\n  }\n}\n\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nexport function create<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const result = validate(value, struct, { coerce: true })\n\n  if (result[0]) {\n    throw result[0]\n  } else {\n    return result[1]\n  }\n}\n\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nexport function mask<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const result = validate(value, struct, { coerce: true, mask: true })\n\n  if (result[0]) {\n    throw result[0]\n  } else {\n    return result[1]\n  }\n}\n\n/**\n * Check if a value passes a struct.\n */\n\nexport function is<T, S>(value: unknown, struct: Struct<T, S>): value is T {\n  const result = validate(value, struct)\n  return !result[0]\n}\n\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nexport function validate<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    coerce?: boolean\n    mask?: boolean\n  } = {}\n): [StructError, undefined] | [undefined, T] {\n  const tuples = run(value, struct, options)\n  const tuple = shiftIterator(tuples)!\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0]\n        }\n      }\n    })\n\n    return [error, undefined]\n  } else {\n    const v = tuple[1]\n    return [undefined, v]\n  }\n}\n\n/**\n * A `Context` contains information about the current location of the\n * validation inside the initial input value.\n */\n\nexport type Context = {\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * A type utility to extract the type from a `Struct` class.\n */\n\nexport type Infer<T extends Struct<any, any>> = T['TYPE']\n\n/**\n * A type utility to describe that a struct represents a TypeScript type.\n */\n\nexport type Describe<T> = Struct<T, StructSchema<T>>\n\n/**\n * A `Result` is returned from validation functions.\n */\n\nexport type Result =\n  | boolean\n  | string\n  | Partial<Failure>\n  | Iterable<boolean | string | Partial<Failure>>\n\n/**\n * A `Coercer` takes an unknown value and optionally coerces it.\n */\n\nexport type Coercer<T = unknown> = (value: T, context: Context) => unknown\n\n/**\n * A `Validator` takes an unknown value and validates it.\n */\n\nexport type Validator = (value: unknown, context: Context) => Result\n\n/**\n * A `Refiner` takes a value of a known type and validates it against a further\n * constraint.\n */\n\nexport type Refiner<T> = (value: T, context: Context) => Result\n","import { Struct, Context, Validator } from '../struct'\nimport { object, optional } from './types'\nimport { ObjectSchema, Assign, ObjectType, PartialObjectSchema } from '../utils'\n\n/**\n * Create a new struct that combines the properties properties from multiple\n * object structs.\n *\n * Like JavaScript's `Object.assign` utility.\n */\n\nexport function assign<A extends ObjectSchema, B extends ObjectSchema>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>\n): Struct<ObjectType<Assign<A, B>>, Assign<A, B>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>\n): Struct<ObjectType<Assign<Assign<A, B>, C>>, Assign<Assign<A, B>, C>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>\n): Struct<\n  ObjectType<Assign<Assign<Assign<A, B>, C>, D>>,\n  Assign<Assign<Assign<A, B>, C>, D>\n>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema,\n  E extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>,\n  E: Struct<ObjectType<E>, E>\n): Struct<\n  ObjectType<Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>,\n  Assign<Assign<Assign<Assign<A, B>, C>, D>, E>\n>\nexport function assign(...Structs: Struct<any>[]): any {\n  const schemas = Structs.map((s) => s.schema)\n  const schema = Object.assign({}, ...schemas)\n  return object(schema)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n */\n\nexport function define<T>(name: string, validator: Validator): Struct<T, null> {\n  return new Struct({ type: name, schema: null, validator })\n}\n\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\nexport function deprecated<T>(\n  struct: Struct<T>,\n  log: (value: unknown, ctx: Context) => void\n): Struct<T> {\n  return new Struct({\n    ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true\n      } else {\n        log(value, ctx)\n        return struct.validator(value, ctx)\n      }\n    },\n  })\n}\n\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nexport function dynamic<T>(\n  fn: (value: unknown, ctx: Context) => Struct<T, any>\n): Struct<T, null> {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    *entries(value, ctx) {\n      const struct = fn(value, ctx)\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nexport function lazy<T>(fn: () => Struct<T, any>): Struct<T, null> {\n  let struct: Struct<T, any> | undefined\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    *entries(value, ctx) {\n      struct ??= fn()\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      struct ??= fn()\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      struct ??= fn()\n      return struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nexport function omit<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Omit<S, K>>, Omit<S, K>> {\n  const { schema } = struct\n  const subschema: any = { ...schema }\n\n  for (const key of keys) {\n    delete subschema[key]\n  }\n\n  return object(subschema as Omit<S, K>)\n}\n\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nexport function partial<S extends ObjectSchema>(\n  struct: Struct<ObjectType<S>, S> | S\n): Struct<ObjectType<PartialObjectSchema<S>>, PartialObjectSchema<S>> {\n  const schema: any =\n    struct instanceof Struct ? { ...struct.schema } : { ...struct }\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key])\n  }\n\n  return object(schema) as any\n}\n\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nexport function pick<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Pick<S, K>>, Pick<S, K>> {\n  const { schema } = struct\n  const subschema: any = {}\n\n  for (const key of keys) {\n    subschema[key] = schema[key]\n  }\n\n  return object(subschema as Pick<S, K>)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nexport function struct<T>(name: string, validator: Validator): Struct<T, null> {\n  console.warn(\n    'superstruct@0.11 - The `struct` helper has been renamed to `define`.'\n  )\n\n  return define(name, validator)\n}\n","import { Infer, Struct } from '../struct'\nimport { define } from './utilities'\nimport {\n  TupleSchema,\n  ObjectSchema,\n  ObjectType,\n  print,\n  run,\n  isObject,\n} from '../utils'\n\n/**\n * Ensure that any value passes validation.\n */\n\nexport function any(): Struct<any, null> {\n  return define('any', () => true)\n}\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n */\n\nexport function array<T extends Struct<any>>(Element: T): Struct<Infer<T>[], T>\nexport function array(): Struct<unknown[], undefined>\nexport function array<T extends Struct<any>>(Element?: T): any {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array value, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a boolean.\n */\n\nexport function boolean(): Struct<boolean, null> {\n  return define('boolean', (value) => {\n    return typeof value === 'boolean'\n  })\n}\n\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nexport function date(): Struct<Date, null> {\n  return define('date', (value) => {\n    return (\n      (value instanceof Date && !isNaN(value.getTime())) ||\n      `Expected a valid \\`Date\\` object, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n */\n\nexport function enums<T extends number>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends string>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends number | string>(values: readonly T[]): any {\n  const schema: any = {}\n  const description = values.map((v) => print(v)).join()\n\n  for (const key of values) {\n    schema[key] = key\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return (\n        values.includes(value as any) ||\n        `Expected one of \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a function.\n */\n\nexport function func(): Struct<Function, null> {\n  return define('func', (value) => {\n    return (\n      typeof value === 'function' ||\n      `Expected a function, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nexport function instance<T extends { new (...args: any): any }>(\n  Class: T\n): Struct<InstanceType<T>, null> {\n  return define('instance', (value) => {\n    return (\n      value instanceof Class ||\n      `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an integer.\n */\n\nexport function integer(): Struct<number, null> {\n  return define('integer', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n      `Expected an integer, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value matches all of a set of types.\n */\n\nexport function intersection<A>(Structs: TupleSchema<[A]>): Struct<A, null>\nexport function intersection<A, B>(\n  Structs: TupleSchema<[A, B]>\n): Struct<A & B, null>\nexport function intersection<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<A & B & C, null>\nexport function intersection<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<A & B & C & D, null>\nexport function intersection<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<A & B & C & D & E, null>\nexport function intersection<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<A & B & C & D & E & F, null>\nexport function intersection<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<A & B & C & D & E & F & G, null>\nexport function intersection<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<A & B & C & D & E & F & G & H, null>\nexport function intersection<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<A & B & C & D & E & F & G & H & I, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A & B & C & D & E & F & G & H & I & J, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<\n  A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q,\n  null\n>\nexport function intersection(Structs: Array<Struct<any, any>>): any {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx)\n      }\n    },\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx)\n      }\n    },\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx)\n      }\n    },\n  })\n}\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n */\n\nexport function literal<T extends boolean>(constant: T): Struct<T, T>\nexport function literal<T extends number>(constant: T): Struct<T, T>\nexport function literal<T extends string>(constant: T): Struct<T, T>\nexport function literal<T>(constant: T): Struct<T, null>\nexport function literal<T>(constant: T): any {\n  const description = print(constant)\n  const t = typeof constant\n  return new Struct({\n    type: 'literal',\n    schema:\n      t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator(value) {\n      return (\n        value === constant ||\n        `Expected the literal \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n */\n\nexport function map(): Struct<Map<unknown, unknown>, null>\nexport function map<K, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Map<K, V>, null>\nexport function map<K, V>(Key?: Struct<K>, Value?: Struct<V>): any {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k as string, k, Key]\n          yield [k as string, v, Value]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Map ||\n        `Expected a \\`Map\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that no value ever passes validation.\n */\n\nexport function never(): Struct<never, null> {\n  return define('never', () => false)\n}\n\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nexport function nullable<T, S>(struct: Struct<T, S>): Struct<T | null, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is a number.\n */\n\nexport function number(): Struct<number, null> {\n  return define('number', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value)) ||\n      `Expected a number, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an object, that is has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n */\n\nexport function object(): Struct<Record<string, unknown>, null>\nexport function object<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S>\nexport function object<S extends ObjectSchema>(schema?: S): any {\n  const knowns = schema ? Object.keys(schema) : []\n  const Never = never()\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value))\n\n        for (const key of knowns) {\n          unknowns.delete(key)\n          yield [key, value[key], schema[key]]\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value\n    },\n  })\n}\n\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nexport function optional<T, S>(struct: Struct<T, S>): Struct<T | undefined, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) =>\n      value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nexport function record<K extends string, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Record<K, V>, null> {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k]\n          yield [k, k, Key]\n          yield [k, v, Value]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nexport function regexp(): Struct<RegExp, null> {\n  return define('regexp', (value) => {\n    return value instanceof RegExp\n  })\n}\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n */\n\nexport function set(): Struct<Set<unknown>, null>\nexport function set<T>(Element: Struct<T>): Struct<Set<T>, null>\nexport function set<T>(Element?: Struct<T>): any {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v as string, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Set ||\n        `Expected a \\`Set\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a string.\n */\n\nexport function string(): Struct<string, null> {\n  return define('string', (value) => {\n    return (\n      typeof value === 'string' ||\n      `Expected a string, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\n\nexport function tuple<A>(Structs: TupleSchema<[A]>): Struct<[A], null>\nexport function tuple<A, B>(Structs: TupleSchema<[A, B]>): Struct<[A, B], null>\nexport function tuple<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<[A, B, C], null>\nexport function tuple<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<[A, B, C, D], null>\nexport function tuple<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<[A, B, C, D, E], null>\nexport function tuple<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<[A, B, C, D, E, F], null>\nexport function tuple<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<[A, B, C, D, E, F, G], null>\nexport function tuple<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<[A, B, C, D, E, F, G, H], null>\nexport function tuple<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<[A, B, C, D, E, F, G, H, I], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<[A, B, C, D, E, F, G, H, I, J], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q], null>\nexport function tuple(Elements: Struct<any>[]): any {\n  const Never = never()\n\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Elements.length, value.length)\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Elements[i] || Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nexport function type<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S> {\n  const keys = Object.keys(schema)\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value matches one of a set of types.\n */\n\nexport function union<A>(Structs: TupleSchema<[A]>): Struct<A, null>\nexport function union<A, B>(Structs: TupleSchema<[A, B]>): Struct<A | B, null>\nexport function union<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<A | B | C, null>\nexport function union<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<A | B | C | D, null>\nexport function union<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<A | B | C | D | E, null>\nexport function union<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<A | B | C | D | E | F, null>\nexport function union<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<A | B | C | D | E | F | G, null>\nexport function union<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<A | B | C | D | E | F | G | H, null>\nexport function union<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<A | B | C | D | E | F | G | H | I, null>\nexport function union<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A | B | C | D | E | F | G | H | I | J, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<\n  A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q,\n  null\n>\nexport function union(Structs: Struct<any>[]): any {\n  const description = Structs.map((s) => s.type).join(' | ')\n  return new Struct({\n    type: 'union',\n    schema: null,\n    validator(value, ctx) {\n      const failures = []\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx)\n        const [first] = tuples\n\n        if (!first[0]) {\n          return []\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure)\n            }\n          }\n        }\n      }\n\n      return [\n        `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(\n          value\n        )}`,\n        ...failures,\n      ]\n    },\n  })\n}\n\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nexport function unknown(): Struct<unknown, null> {\n  return define('unknown', () => true)\n}\n","import { Struct, is, Coercer } from '../struct'\nimport { isPlainObject } from '../utils'\nimport { string, unknown } from './types'\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function coerce<T, S, C>(\n  struct: Struct<T, S>,\n  condition: Struct<C, any>,\n  coercer: Coercer<C>\n): Struct<T, S> {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition)\n        ? struct.coercer(coercer(value, ctx), ctx)\n        : struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function defaulted<T, S>(\n  struct: Struct<T, S>,\n  fallback: any,\n  options: {\n    strict?: boolean\n  } = {}\n): Struct<T, S> {\n  return coerce(struct, unknown(), (x) => {\n    const f = typeof fallback === 'function' ? fallback() : fallback\n\n    if (x === undefined) {\n      return f\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x }\n      let changed = false\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key]\n          changed = true\n        }\n      }\n\n      if (changed) {\n        return ret\n      }\n    }\n\n    return x\n  })\n}\n\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function trimmed<T, S>(struct: Struct<T, S>): Struct<T, S> {\n  return coerce(struct, string(), (x) => x.trim())\n}\n","import { Struct, Refiner } from '../struct'\nimport { toFailures } from '../utils'\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nexport function empty<\n  T extends string | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>): Struct<T, S> {\n  const expected = `Expected an empty ${struct.type}`\n\n  return refine(struct, 'empty', (value) => {\n    if (value instanceof Map || value instanceof Set) {\n      const { size } = value\n      return (\n        size === 0 || `${expected} but received one with a size of \\`${size}\\``\n      )\n    } else {\n      const { length } = value as string | any[]\n      return (\n        length === 0 ||\n        `${expected} but received one with a length of \\`${length}\\``\n      )\n    }\n  })\n}\n\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nexport function max<T extends number | Date, S extends any>(\n  struct: Struct<T, S>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T, S> {\n  const { exclusive } = options\n  return refine(struct, 'max', (value) => {\n    return exclusive\n      ? value < threshold\n      : value <= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nexport function min<T extends number | Date, S extends any>(\n  struct: Struct<T, S>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T, S> {\n  const { exclusive } = options\n  return refine(struct, 'min', (value) => {\n    return exclusive\n      ? value > threshold\n      : value >= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\nexport function pattern<T extends string, S extends any>(\n  struct: Struct<T, S>,\n  regexp: RegExp\n): Struct<T, S> {\n  return refine(struct, 'pattern', (value) => {\n    return (\n      regexp.test(value) ||\n      `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`\n    )\n  })\n}\n\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nexport function size<\n  T extends string | number | Date | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>, min: number, max: number = min): Struct<T, S> {\n  const expected = `Expected a ${struct.type}`\n  const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``\n\n  return refine(struct, 'size', (value) => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return (\n        (min <= value && value <= max) ||\n        `${expected} ${of} but received \\`${value}\\``\n      )\n    } else if (value instanceof Map || value instanceof Set) {\n      const { size } = value\n      return (\n        (min <= size && size <= max) ||\n        `${expected} with a size ${of} but received one with a size of \\`${size}\\``\n      )\n    } else {\n      const { length } = value as string | any[]\n      return (\n        (min <= length && length <= max) ||\n        `${expected} with a length ${of} but received one with a length of \\`${length}\\``\n      )\n    }\n  })\n}\n\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nexport function refine<T, S>(\n  struct: Struct<T, S>,\n  name: string,\n  refiner: Refiner<T>\n): Struct<T, S> {\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx)\n      const result = refiner(value, ctx)\n      const failures = toFailures(result, ctx, struct, value)\n\n      for (const failure of failures) {\n        yield { ...failure, refinement: name }\n      }\n    },\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}